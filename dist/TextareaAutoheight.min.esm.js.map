{"version":3,"sources":["TextareaAutoheight.esm.js"],"names":["_supportCSSTypedOM","__classPrivateFieldSet","this","receiver","privateMap","value","has","TypeError","set","__classPrivateFieldGet","get","TextareaHeightAdjust","HTMLTextAreaElement","[object Object]","super","undefined","attributeStyleMap","_inputEvent","addEventListener","passive","removeEventListener","heightPx","scrollHeight","textareaComputedStyleMap","computedStyleMap","borderTopWidthPx","borderBottomWidthPx","CSS","px","style","height","textareaComputedStyle","getComputedStyle","boxSizing","Number","parseInt","borderTopWidth","isNaN","borderBottomWidth","WeakMap"],"mappings":"AAAA,IAaIA,EAbAC,EAA0BC,MAAQA,KAAKD,wBAA2B,SAAUE,EAAUC,EAAYC,GAClG,IAAKD,EAAWE,IAAIH,GAChB,MAAM,IAAII,UAAU,kDAGxB,OADAH,EAAWI,IAAIL,EAAUE,GAClBA,GAEPI,EAA0BP,MAAQA,KAAKO,wBAA2B,SAAUN,EAAUC,GACtF,IAAKA,EAAWE,IAAIH,GAChB,MAAM,IAAII,UAAU,kDAExB,OAAOH,EAAWM,IAAIP,mBAQX,MAAMQ,UAA6BC,oBAC9CC,cACIC,QACAd,EAAmBQ,IAAIN,UAAM,GAC7BD,EAAuBC,KAAMF,OAA+Ce,IAA3Bb,KAAKc,mBAE1DH,oBACIX,KAAKe,cACLf,KAAKgB,iBAAiB,QAAShB,KAAKe,YAAa,CAAEE,SAAS,IAEhEN,uBACIX,KAAKkB,oBAAoB,QAASlB,KAAKe,aAK3CJ,cACI,GAAIJ,EAAuBP,KAAMF,GAAqB,CAClDE,KAAKc,kBAAkBR,IAAI,SAAU,SACrC,IAAIa,EAAWnB,KAAKoB,aACpB,MAAMC,EAA2BrB,KAAKsB,mBACtC,OAAQD,EAAyBb,IAAI,eAAeL,OAChD,IAAK,aAAc,CACf,MAAMoB,EAAmBF,EAAyBb,IAAI,yBAC7BK,IAArBU,IACAJ,GAAYI,EAAiBpB,OAEjC,MAAMqB,EAAsBH,EAAyBb,IAAI,4BAC7BK,IAAxBW,IACAL,GAAYK,EAAoBrB,OAEpC,OAGRH,KAAKc,kBAAkBR,IAAI,SAAUmB,IAAIC,GAAGP,QAE3C,CACDnB,KAAK2B,MAAMC,OAAS,QACpB,IAAIT,EAAWnB,KAAKoB,aACpB,MAAMS,EAAwBC,iBAAiB9B,KAAM,IACrD,OAAQ6B,EAAsBE,WAC1B,IAAK,aAAc,CACf,MAAMR,EAAmBS,OAAOC,SAASJ,EAAsBK,gBAC1DF,OAAOG,MAAMZ,KACdJ,GAAYI,GAEhB,MAAMC,EAAsBQ,OAAOC,SAASJ,EAAsBO,mBAC7DJ,OAAOG,MAAMX,KACdL,GAAYK,GAEhB,OAGRxB,KAAK2B,MAAMC,OAAS,GAAGT,QAInCrB,EAAqB,IAAIuC","file":"TextareaAutoheight.esm.js","sourcesContent":["var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _supportCSSTypedOM;\n/**\n * Automatically adjust the height of the `<textarea>` element according to the input content.\n *\n * @version 1.0.0\n */\nexport default class TextareaHeightAdjust extends HTMLTextAreaElement {\n    constructor() {\n        super();\n        _supportCSSTypedOM.set(this, void 0); // CSS Typed Object Model に対応しているか https://caniuse.com/mdn-api_element_attributestylemap\n        __classPrivateFieldSet(this, _supportCSSTypedOM, this.attributeStyleMap !== undefined);\n    }\n    connectedCallback() {\n        this._inputEvent();\n        this.addEventListener('input', this._inputEvent, { passive: true });\n    }\n    disconnectedCallback() {\n        this.removeEventListener('input', this._inputEvent);\n    }\n    /**\n     * 入力時の処理\n     */\n    _inputEvent() {\n        if (__classPrivateFieldGet(this, _supportCSSTypedOM)) {\n            this.attributeStyleMap.set('height', 'unset');\n            let heightPx = this.scrollHeight;\n            const textareaComputedStyleMap = this.computedStyleMap();\n            switch (textareaComputedStyleMap.get('box-sizing')?.value) {\n                case 'border-box': {\n                    const borderTopWidthPx = textareaComputedStyleMap.get('border-top-width');\n                    if (borderTopWidthPx !== undefined) {\n                        heightPx += borderTopWidthPx.value;\n                    }\n                    const borderBottomWidthPx = textareaComputedStyleMap.get('border-bottom-width');\n                    if (borderBottomWidthPx !== undefined) {\n                        heightPx += borderBottomWidthPx.value;\n                    }\n                    break;\n                }\n            }\n            this.attributeStyleMap.set('height', CSS.px(heightPx));\n        }\n        else {\n            this.style.height = 'unset';\n            let heightPx = this.scrollHeight;\n            const textareaComputedStyle = getComputedStyle(this, '');\n            switch (textareaComputedStyle.boxSizing) {\n                case 'border-box': {\n                    const borderTopWidthPx = Number.parseInt(textareaComputedStyle.borderTopWidth);\n                    if (!Number.isNaN(borderTopWidthPx)) {\n                        heightPx += borderTopWidthPx;\n                    }\n                    const borderBottomWidthPx = Number.parseInt(textareaComputedStyle.borderBottomWidth);\n                    if (!Number.isNaN(borderBottomWidthPx)) {\n                        heightPx += borderBottomWidthPx;\n                    }\n                    break;\n                }\n            }\n            this.style.height = `${heightPx}px`;\n        }\n    }\n}\n_supportCSSTypedOM = new WeakMap();\n"]}